## 프록시 패턴
프록시의 사전적인 의미는 대리, 대리인이다. 뜻처럼 클라이언트는 클래스를 직접 사용하는 것이 아니라 프록시라는 대리인을 거쳐서 사용한다. 
맨 처음 요청은 무조건 프록시를 사용하게 된다.
ex) 사장을 만나기 위해서 비서를 거치는 것처럼..

프록시를 사용하게 되면 해당 객체에 대한 접근 제어, 지연 초기화, 로깅, 캐싱 등 다양하게 응용해서 사용할 수 있다.

### 구현
간단하게 프록시 패턴을 구현해보자.  
파일을 다운로드 하면 다운로드한 시간을 로그로 남기는 서비스  
```java
// Subject
public interface FileDownloader {
    void download(String url);
}

// RealSubject
public class RealFileDownloader implements FileDownloader {
    @Override
    public void download(String url) {
        System.out.println(url + "을 다운로드 했습니다.");
    }
}

// Proxy
public class FileDownloadProxy implements FileDownloader {

    // 인터페이스 타입의 필드를 가지고 있는 이유는 기존의 있는 코드를 재사용하기 위해서
    private FileDownloader fileDownloader;

    public FileDownloadProxy(FileDownloader fileDownloader) {
        this.fileDownloader = fileDownloader;
    }

    @Override
    public void download(String url) {
        long before = System.currentTimeMillis();
        // 재사용
        fileDownloader.download(url);
        System.out.println(System.currentTimeMillis() - before);
    }
}
```
```java
// Client
public class Client {
    public static void main(String[] args) {
        FileDownloader fileDownloader = new FileDownloadProxy(new RealFileDownloader());
        String url = "file.txt";
        fileDownloader.download(url);
    }
}
```
![image](https://github.com/hong-gp/study/assets/127091213/35fa8edb-4d75-4f6c-b41d-fabbcf2b0927)
<br/>

클라이언트에서는 FileDownloader와 Proxy를 사용하고 있고, 프록시 안에서는 RealSubject를 사용하고 있는 것이다.  
클라이언트가 RealFileDownloader를 쓰긴 써야하는데 직접 사용하는 것이 아니라 반드시 프록시를 거쳐서 사용하는 것이다.
<br/>

RealFileDownloader는 원래 자신이 해야하는 일만 할 수 있고, 부가적인 일은 프록시에서 하고 있다.  
여기서 지연 초기화를 하고 싶다면  
```java
public class FileDownloadProxy implements FileDownloader {

    private FileDownloader fileDownloader;

    @Override
    public void download(String url) {
        long before = System.currentTimeMillis();
        if (fileDownloader == null) {
            fileDownloader = new RealFileDownloader();
        }
        fileDownloader.download(url);
        System.out.println(System.currentTimeMillis() - before);
    }
}

public class Client {
    public static void main(String[] args) {
        FileDownloader fileDownloader = new FileDownloadProxy();
        String url = "file.txt";
        fileDownloader.download(url);
    }
}
```
FileDownloadProxy와 Client를 이렇게 수정할 수 있다.  
<br/><br/>

### UML

<br/><br/>

### 장단점
- 장점
    - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다. (OCP)
    - 기존 코드가 해야하는 일만 할 수 있다. (SRP)
    - 다양하게 활용할 수 있다.
- 단점
    - 새로운 클래스들을 많이 도입해야 하므로 코드가 복잡해질 수 있다.
