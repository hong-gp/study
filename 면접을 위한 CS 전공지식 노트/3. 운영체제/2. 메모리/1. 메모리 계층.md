## RAM
RAM은 저장 장치와 CPU를 연결해주는 역할을 한다. 속도가 느린 저장장치의 데이터를 미리 램에
담아두었다가 CPU가 바로 불러서 처리할 수 있는 형태다.  

CPU의 처리속도가 저장장치의 속도보다 훨씬 빠르기 떄문에 이를 극복하기 위해 RAM을 사용한다. 
SSD와 RAM은 30~40배 이상의 성능차이가 난다.  

그럼에도 CPU의 속도를 따라가진 못한다.  

<br/>

## DRAM의 한계
DRAM의 성장 속도는 점점 줄어들고 있다. 성장이 둔화하는 것과는 다르게 데이터 처리량은 급격히 증가하고 있다. 
메모리 요구량과 DRAM의 성장 차이가 커지면서 해결할 방법이 중요해졌다.  

DRAM을 대체할 수 있는 대안 연구가 활발하지만 기존 DRAM을 접근하는 것 만큼 좋은 성능을 내지 못하고 있다. 
그래서 나온 새로운 대안이 DRAM이 대안 메모리의 캐시처럼 동작하는 것이 현실적이다.  

<br/>

## 메모리 계층
![image](https://github.com/hong-gp/study/assets/127091213/9ca85095-09f7-4b11-ae8a-3b29c0abda62)  

컴퓨터를 조립하자. CPU를 사고 메모리를 샀다. 
메모리에서 데이터를 가져다가 CPU에서 연산을 하고 결과를 다시 메모리에 저장한다. 
성능 좋은 새로운 메모리가 등장한다. 이름은 캐시.
메모리를 캐시로 바꿔버리면 되지만 너무 비싸다. 
기존의 메모리가 50M이라고 하고 우리가 살 수 있는 캐시는 2M밖에 안된다. 완전히 대체를 못한다.
프로그램은 지역성이라는 특성이 있다. 그러면 캐시라는 메모리를 사이에 두고
메인메모리에서 블럭을 25개로 나눈다고 했을 때 블럭 단위로 실행중인 블럭을 캐시에 올려서 CPU가 캐시를 통해 연산을 하도록 하자
그럼 계층 구조가 된다. 
더 좋은 새로운 메모리가 등장하면 계층이 하나 더 생길 것이다. 

그림을 보면 하드디스크는 메인 메모리가 캐시다. CPU에게 직접적으로 주지 않고 자신보다 좀 더 빠른 메인메모리에게 넘겨준다.

CPU가 데이터가 필요하다고 메인 메모리에게 물어본다. 메인메모리에 해당 데이터가 없으면 하드디스크에게 요청할 것이다. 
하드디스크는 데이터를 줄 것이고 메인메모리가 다시 CPU에게 줄 것이다.
레지스터는 캐시에게, 캐시는 메인메모리에게, 메인메모리는 하드디스크에게 물어보는 상황이 생기면 하드디스크에게 바로 요청하는 것이
빠르지 않을까?

프로그램이 산발적이라면 계층 구조가 더 부담스러울 것이다. 지역성이라는 특징때문에 계층 구조의 성능이 좋아진다.

---
### 참고
- https://www.youtube.com/watch?v=QRww8UX07jw
