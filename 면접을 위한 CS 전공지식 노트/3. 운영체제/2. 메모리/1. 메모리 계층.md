## 메모리 계층 (Memory Hierarchy)

![image](https://github.com/hong-gp/study/assets/127091213/9ca85095-09f7-4b11-ae8a-3b29c0abda62)  

- 레지스터
    - 컴퓨터에서 제일 빠른 메모리
    - 프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역 
- 캐시
    - 레지스터 다음으로 빠른 메모리이며 CPU 내부에 존재
    - 용량은 비교적 작지만 가장 자주 사용되는 데이터를 가지고 있으면서 CPU의 메모리 접근 시간을 줄여준다.
    - CPU가 필요로 하는 데이터가 레지스터에 없는 경우 주기억장치로부터 데이터를 읽어오려면 오랜 시간이 걸린다. 특히 대규모 컴퓨터 시스템에서는 물리적 거리로 인해 더 오래 걸린다.
- 주기억장치 (Main Memory)
    - CPU나 메인보드와 분리되어 있는 메모리 중 최상위 메모리
    - CPU에서 직접 접근이 가능하지만 캐시에 비해 훨씬 느리다.
- 보조기억장치
    - CPU에서 직접 접근이 불가능한 메모리

> SRAM (Static RAM) : 전원이 공급되는 한, 내용을 계속 가지고 있는 RAM  
> DRAM (Dynamic RAM) : 기록된 내용을 유지하기 위해 주기적으로 재충전이 필요함   
> L1 Cache : 프로세서와 가장 가까운 캐시  
> L2 Cache : 용량이 큰 캐시  
> L3 Cache : 멀티 코어 시스템에서 여러 코어가 공유하는 캐시  

위로 갈수록 빨라지고 비싸지며 용량은 적어진다.  

자주 접근하는 데이터를 더 빠르고 작은 메모리 수준에 저장하고, 
자주 접근하지 않는 데이터를 더 느리지만 큰 메모리 수준에 저장함으로써 
효율적인 데이터 접근을 보장한다. 

프로그램이 산발적이라면 계층 구조가 더 부담스러울 것이다. 지역성이라는 특징때문에 계층 구조의 성능이 좋아진다.  

<br/>

## Locality (지역성)
- CPU가 기억장치의 특정 부분에 위치한 데이터나 프로그램 코드를 집중적으로 엑세스하는 현상
- 고비용/고속 저장장치의 효율적 사용 및 속도 향상 가능

![image](https://github.com/hong-gp/study/assets/127091213/6fe7a1d8-f892-493e-ba39-0c2726cafc9b)

<br/>

```java
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}
```  

### Temporal Locality (시간적 지역성)
- 최근 사용된 데이터는 가까운 미래에 다시 액세스할 가능성이 높다.
- 변수 `i`는 짧은 시간안에 여러번 접근이 이뤄진다.

<br/>

### Spatial Locality (공간적 지역성) 
- 최근 사용된 데이터가 있는 기억공간에 접근할 가능성이 높다.
- CPU가 실행하려는 프로그램은 관련된 데이터끼리 모여있는 경우가 많다. 
- 배열 `arr`의 각 요소를 참조하면서 가까운 공간에 연속적으로 접근하고 있다.

<br/>

## 캐시 메모리
CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치.  
캐시 메모리는 메모리보다 용량이 작기때문에 메모리의 모든 내용을 저장하지 못함.  

### 캐시 히트
CPU에서 요청한 데이터가 캐시에 존재하는 경우

### 캐시 미스
CPU에서 요청한 데이터가 캐시에 존재하지 않는 경우

<br/>

캐시 히트 시 CPU 내부에 있기 때문에 CPU 내부 버스 기반으로 작동해 빠르고, 
캐시 미스는 메모리까지 접근하기 떄문에 시스템 버스를 기반으로 작동해 느리다.  

- 시스템 버스 : 메모리와 주변장치를 연결하는 버스
- CPU 내부 버스 : CPU 내부에 있는 장치를 연결하는 버스

> 캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)  
> 캐시 적중률은 보통 80~90% 이상이다. 

<br/>

## 캐시 매핑
- 워드
    - CPU가 한 번에 처리할 수 있는 데이터의 크기
- 블록
    - 여러개의 워드의 집합
    - 캐시는 블록 단위로 데이터를 저장한다.
 
캐시는 메모리보다 작기 때문에 동일한 캐시 블록에 다수의 메모리 블록이 매핑될 수 있다.  
캐시의 1번 블록에 메모리의 1번, 5번 블록이 매핑될 수 있다.  

### 캐시 기본 동작
1. CPU가 원하는 데이터 주소를 캐시에 요청
2. 캐시 메모리에서 태그를 비교한다.
3. 태그 일치하면 해당 블록에 접근해서 원하는 데이터를 CPU로 전송
4. 태그가 불일치하면 메모리에서 블록을 캐시로 가져온다.
5. 메모리에도 존재하지 않으면 페이지 폴트 발생

어떻게 메모리 블록을 캐시 블록에 매핑하는 걸까?  

<br/>

### 직접 매핑 (direct mapping)
메인 메모리의 각 블럭들이 캐시에 들어갈 자리가 미리 정해져있고 일련의 규칙대로 캐시와 메인 메모리가 매핑되는 방식이다.  
메인 메모리와 동일하 배열을 가지도록 매핑된다.  

![image](https://github.com/hong-gp/study/assets/127091213/7ee0a260-ee9e-41ba-8608-5cda7a5a84cb)

- 캐시 적중률이 낮다.
- 캐시 메모리에 빈 공간이 있어도 저장된 공간이 있다면 내보내야 한다.

<br/>

### 연관 매핑 (associative mapping)
직접 매핑의 단점을 보완하기 위해 등장  
캐시에 저장된 데이터는 메인 메모리의 순서와 관련이 없고 규칙도 없다.  

저장될 위치를 정의할 필요가 없어서 블록 번호가 필요없다.  

![image](https://github.com/hong-gp/study/assets/127091213/b39e100a-84e3-4a53-91fe-15e96881a7c4)

- 규칙이 없기에 캐시를 전부 탐색하며 태그를 일일히 대응하는 과정을 거친다.
- 시간이 오래걸림

<br/>

### 집합 연관 매핑 (set associative mapping)
직접 매핑과 연관 매핑을 합쳐 놓은 것  
직접 사상처럼 set으로 위치를 지정하고, set 내에서는 연관 사상처럼 자유롭게 연결

![image](https://github.com/hong-gp/study/assets/127091213/4d5fd0c4-05a5-41c9-b71e-3dd7ea7a59df)

- 세트 번호를 통해 영역을 탐색
- 세트 안의 라인 수에 따라서 n-way 연관 매핑이라고 한다. 

<br/>

## 웹 브라우저 캐시

### 쿠키
브라우저에 저장되는 key와 value로 이루어진 작은 크기의 문자열

- 4KB 크기 제한
- 만료 시간 설정
- HTTP 요청시 따로 설정하지 않아도 자동으로 전달된다.

HTTP는 비연결성과 무상태라는 특성이 있기 때문에 응답을 받으면 연결이 끊긴다. 
같은 클라이언트가 다음에 다시 서버에 요청시에 클라이언트를 식별하지 못한다.

연결이 끊겨도 기억하고 싶은 정보를 저장할 때 쿠키를 사용할 수 있다.  

쿠키가 요청시에 서버에서 유저의 정보를 저장해서 보내주면 클라이언트는 이 쿠키와 함께 다음 요청시에 
서버에서 클라이언트가 누군지 식별할 수 있는 것이다. 

- 로그인
- 며칠동안 보지않기

#### 단점
- 적은 용량
- HTTP 요청 시 모든 쿠키가 자동 전달
    - 불필요한 트래픽 양 증가
- XSS, XSRF 공격에 취약
    - XSS : 공격자가 악성 스크립트를 삽입하여 브라우저에서 실행
        - ex) input에 쿠키를 조회하는 스크립트를 작성해서 보내면 스크립트가 실행된다.
    - XSRF : 사용자인 척 악성 request를 보내는 공격
        - ex) 송금을 하는 Request URL이 `bank.com/trnsfer?money=${money}&to=${person}`일 때
        - 위조 사이트로 유도를 해서 이미지 소스에 Request URL을 설정하고 사용자가 클릭했을 때
        - 쿠키에 저장되어있는 유저 정보로 송금을 하게되는 공격
     
#### 해결 방법
- XSS : HttpOnly 속성
    - 자바스크립트로 쿠키를 조회하는 것을 방지
- CSRF : SameSite 속성
    - strict : 사이트와 같은 도메인 요청에만 쿠키를 전송
    - Lax : 안전한 메서드, 작업이 최상위 레벨 Navigation에서 이루어지는 경우 쿠키를 전송
- Secure 속성
    - HTTPS로 통신하는 경우에만 쿠키 전송

<br/>

### 웹 스토리지
HTML5 부터 지원하는 브라우저에 데이터를 저장할 수 있는 API  

- 5MB의 정보 저장 가능
- 자동으로 서버에 전송되지 않음
- 오리진 단위로 접근이 제한
    - 오리진 : HTTP, HTTPS의 프로토콜, 도메인, 포트 번호로 이루어진 단위
 
|구분|로컬 스토리지|세션 스토리지|
|-----|-----|-----|
|저장 범위|도메인 별|도메인/탭 별|
|삭제 기준|직접 삭제|브라우저나 탭을 닫을 시|
|활용 예시|- 글 임시 저장 <br/> - 사용자 설정 저장|- 입력폼 저장 <br/> - 일회성 로그인|

#### 단점
- 만료 기간 설정 불가
- 동기적으로 실행
    - 메인 스레드 블로킹
    - 용량이 크면 indexedDB를 고려
- 미지원하는 브라우저 : 에러처리 필수
- XSS 공격에 취약

<br/>

## 인메모리 데이터베이스 (In-memory database)
- 기존 DB가 디스크에서 데이터를 관리하는 반면, In-memory db는 메모리에 데이터를 업로드해서 사용
- 대용량 데이터 증가와 실시간 트랜잭션의 증가로 고성능 처리 요구에 대응 목적
- 메모리에 저장하디 때문에 휘발성으로 인한 오류 복구가 주요 해결 과제 

데이터베이스보다 더 자주 접근하고 덜 자주 바뀌는 데이터를 저장하는 In-memory database 

## redis (remote dictionary server)
외부에서 사전 형태의 구조를 사용하는 서버  
메모리에 저장하는 Key-Value 기반의 NoSQL DBMS 

### 특징
- 메모리에 저장되어 빠른 속도로 접근 가능
- 다양한 자료 구조 제공
- Single Thread
    - 한번에 하나의 명령만을 처리
    - Race Condition이 거의 발생하지 않음
        - 2개 이상의 프로세스가 거의 동시적으로 하나의 리소스에 접근하려고 경쟁하는 상태
- Persistence
    - 메모리에 저장된 데이터를 디스크에 영속화
    - RDB 방식 : 순간적으로 메모리에 있는 내용을 DISK에 전체를 옮겨 담는 방식
    - AOF 방식 : Redis에 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태

레디스는 고성능 키-값 저장소로서 문자열, 리스트, 해시, 셋, 정렬된 셋 형식 등의 데이터를 지원하는 NoSQL이다.

<br/>

---
### 참고
- https://www.youtube.com/watch?v=QRww8UX07jw
- https://blog.skby.net/%EC%A7%80%EC%97%AD%EC%84%B1-locality/
- https://parksb.github.io/article/29.html
- https://sujinhope.github.io/2020/03/13/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0-%EC%BA%90%EC%8B%9C,%EB%A9%94%EB%AA%A8%EB%A6%AC,%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EC%B0%A8%EC%9D%B4.html
- https://code-piggy.tistory.com/entry/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC
- https://www.youtube.com/watch?v=qLCP0PwRp_w
- https://star7sss.tistory.com/930
