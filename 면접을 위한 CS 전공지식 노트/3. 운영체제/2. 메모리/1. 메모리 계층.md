## 메모리 계층 (Memory Hierarchy)
![image](https://github.com/hong-gp/study/assets/127091213/9ca85095-09f7-4b11-ae8a-3b29c0abda62)  

> L1 Cache : 프로세서와 가장 가까운 캐시  
> L2 Cache : 용량이 큰 캐시  
> L3 Cache : 멀티 코어 시스템에서 여러 코어가 공유하는 캐시  

위로 갈수록 빨라지고 비싸지며 용량은 적어진다.  

메모리 계층 구조는 데이터 병목 현상을 해결하기 위해 생겼다. 기술의 발전으로 CPU의 속도는 빠른 속도로 발전한 반면, 
메모리의 CPU의 속도를 따라가지 못했다. CPU가 아무리 빨라도 메모리의 처리 속도가 느리면 전체 시스템의 속도는 느려진다.  
메모리 접근 속도를 높여서 전체적인 프로그램의 속도를 향상시키는 것이 메모리 계층 구조다.  

캐시 메모리나 주기억장치의 용량을 늘리는 것은 비용적인 문제가 있다.  

RAM과 주로 자료를 주고 받는다고 할 때, CPU에게는 RAM이 느리게 느껴진다. 
그래서 CPU는 자주 쓰는 데이터들을 캐시 메모리에 넣어서 사용한다.  

프로그램이 산발적이라면 계층 구조가 더 부담스러울 것이다. 지역성이라는 특징때문에 계층 구조의 성능이 좋아진다.  

<br/>

## Locality (지역성)
- CPU가 기억장치의 특정 부분에 위치한 데이터나 프로그램 코드를 집중적으로 엑세스하는 현상
- 고비용/고속 저장장치의 효율적 사용 및 속도 향상 가능

![image](https://github.com/hong-gp/study/assets/127091213/6fe7a1d8-f892-493e-ba39-0c2726cafc9b)

<br/>

```java
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}
```  

### Temporal Locality (시간적 지역성)
- 최근 사용된 데이터는 가까운 미래에 다시 액세스할 가능성이 높다.
- 변수 `i`는 짧은 시간안에 여러번 접근이 이뤄진다.

<br/>

### Spatial Locality (공간적 지역성) 
- 최근 사용된 데이터가 있는 기억공간에 접근할 가능성이 높다.
- 배열 `arr`의 각 요소를 참조하면서 가까운 공간에 연속적으로 접근하고 있다.

<br/>

## 캐시 메모리
CPU와 메모리 사이에 위치한 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치.  
CPU가 메모리에 접근하는건 오래 걸리니 캐시 메모리를 둬서 쓰자.  

### 캐시 히트
CPU에서 요청한 데이터가 캐시에 존재하는 경우

### 캐시 미스
CPU에서 요청한 데이터가 캐시에 존재하지 않는 경우

<br/>

캐시 히트 시 CPU 내부에 있거나 매우 가까운 곳에 있기 때문에 CPU 내부 버스 기반으로 작동해 빠르고, 
캐시 미스는 메모리까지 접근하기 떄문에 시스템 버스를 기반으로 작동해 느리다.  

- 시스템 버스 : 메모리와 주변장치를 연결하는 버스
- CPU 내부 버스 : CPU 내부에 있는 장치를 연결하는 버

> 캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)  
> 캐시 적중률은 보통 90%이상이다. 

<br/>

## 캐시 매핑
- 워드
    - CPU가 한 번에 처리할 수 있는 데이터의 크기
- 블록
    - 여러개의 워드의 집합
    - 캐시는 블록 단위로 데이터를 저장한다.
 
캐시는 메모리보다 작기 때문에 각 캐시 블록은 메모리의 여러 블록들에 매핑될 수 있다.  
캐시의 1번 블록에 메모리의 1번, 5번 블록이 매핑될 수 있다면 이걸 구분할 수 있는 태그가 필요하다.

### 캐시 기본 동작
1. CPU가 원하는 데이터 주소를 캐시에 요청
2. 캐시 메모리에서 태그를 비교한다.
3. 태그 일치하면 해당 블록에 접근해서 원하는 데이터를 CPU로 전송
4. 태그가 불일치하면 메모리에서 블록을 캐시로 가져온다.
5. 메모리에도 존재하지 않으면 페이지 폴트 발생

<br/>

### 직접 매핑 (direct mapping)
메인 메모리의 각 블럭들이 캐시에 들어갈 자리가 미리 정해져있고 일련의 규칙대로 캐시와 메인 메모리가 매핑되는 방식이다.  
메인 메모리와 동일하 배열을 가지도록 매핑된다.  

![image](https://github.com/hong-gp/study/assets/127091213/7ee0a260-ee9e-41ba-8608-5cda7a5a84cb)

- 캐시 적중률이 낮다.
- 캐시 메모리에 빈 공간이 있어도 저장된 공간이 있다면 내보내야 한다.

<br/>

### 연관 매핑 (associative mapping)
직접 매핑의 단점을 보완하기 위해 등장  
캐시에 저장된 데이터는 메인 메모리의 순서와 관련이 없고 규칙도 없다.  

저장될 위치를 정의할 필요가 없어서 블록 번호가 필요없다.  

![image](https://github.com/hong-gp/study/assets/127091213/b39e100a-84e3-4a53-91fe-15e96881a7c4)

- 규칙이 없기에 캐시를 전부 탐색하며 태그를 일일히 대응하는 과정을 거친다.
- 시간이 오래걸림

<br/>

### 집합 연관 매핑 (set associative mapping)
직접 매핑과 연관 매핑을 합쳐 놓은 것  
직접 사상처럼 set으로 위치를 지정하고, set 내에서는 연관 사상처럼 자유롭게 연결

![image](https://github.com/hong-gp/study/assets/127091213/4d5fd0c4-05a5-41c9-b71e-3dd7ea7a59df)

- 세트 번호를 통해 영역을 탐색
- 세트 안의 라인 수에 따라서 n-way 연관 매핑이라고 한다. 

<br/>

---
### 참고
- https://www.youtube.com/watch?v=QRww8UX07jw
- https://blog.skby.net/%EC%A7%80%EC%97%AD%EC%84%B1-locality/
- https://parksb.github.io/article/29.html
- https://sujinhope.github.io/2020/03/13/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0-%EC%BA%90%EC%8B%9C,%EB%A9%94%EB%AA%A8%EB%A6%AC,%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EC%B0%A8%EC%9D%B4.html
- https://code-piggy.tistory.com/entry/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC
- https://www.youtube.com/watch?v=qLCP0PwRp_w
- https://star7sss.tistory.com/930
